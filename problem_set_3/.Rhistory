geom_line() +
labs(x="Time in Months", y = "Email rechable member lift", title="Lift from horoscopes by month")
horoscope_lift
library(tidyverse)
library(RPostgreSQL)
library(markovchain)
connection = dbConnect(PostgreSQL(),
host="woden-redshift.p11a.com",
user="clay",
password="3P@1yKS0mIGvso1m6ZSh3VN%ZyJhM4h%",
dbname="woden",
port="5439")
user_engagement_by_msl_c = dbGetQuery(connection, paste("select * from user_engagement_by_msl_c"))
create_transition_matrix = function(df, cohort, num_states) {
df$user_ctr = with(df, user_clicks/users_sent)
df = df %>%
filter(test_control_flag == cohort) %>%
mutate(msl_c = msl_c + 1)
tm = matrix(rep(rep(0,num_states*num_states)),nrow=num_states,byrow=TRUE)
tm[1,2] = with(df %>% filter(arrival_type == 'r'), user_ctr)
tm[1,8] = with(df %>% filter(arrival_type == 'r'), 1 - user_ctr)
df = df %>% filter(arrival_type == 'e')
for (i in 2:(num_states-1)) {
user_ctr = with(df %>% filter(msl_c + 1 == i), user_ctr)
tm[i,i] = user_ctr
tm[i,i+1] = 1 - user_ctr
}
tm[8,8] = 1
tm
}
future_states = function(transition_matrix,state_names,initial_state, mc_name,time_periods=3) {
mc = new("markovchain", transitionMatrix=transition_matrix,states=state_names, name=mc_name)
num_states = length(initial_state)
states = matrix(rep(rep(0,num_states),time_periods),nrow=time_periods,byrow=TRUE)
for (i in 1:time_periods) {
if (i == 1)
next_state = initial_state*mc
else
next_state = states[i-1,]*mc
states[i,] = next_state
states[i,1] = 1200e3
}
return (states)
}
state_names = c("reg",0:6)
initial_state = c(932235,4366492,1404832,974552,830495,755575,587513,0)
# transition matrix for horoscope control
# tm <- c(c(0,0.50767681084216,0,0,0,0,0,1-0.50767681084216),
#         c(0,0.807562904585403,1-0.807562904585403,0,0,0,0,0),
#         c(0,0.095015298975791,0,1-0.095015298975791,0,0,0,0),
#         c(0,0.0724145205092642,0,0,1-0.0724145205092642,0,0,0),
#         c(0,0.0425663805949148,0,0,0,1-0.0425663805949148,0,0),
#         c(0,0.0361778900550916,0,0,0,0,1-0.0361778900550916,0),
#         c(0,0.0403998334027489,0,0,0,0,0,1-0.0403998334027489),
#         c(0,0,0,0,0,0,0,1)
# )
tm_control = create_transition_matrix(user_engagement_by_msl_c, 'CONTROL', 8)
states_control = future_states(tm_control, state_names, initial_state, "Horoscope control", 20)
# transition matrix for newsletter test
# tm <- c(c(0,0.507573048652163,0,0,0,0,0,1-0.507573048652163),
#         c(0,0.822892747445351,1-0.822892747445351,0,0,0,0,0),
#         c(0,0.116821861476424,0,1-0.116821861476424,0,0,0,0),
#         c(0,0.0764079444838941,0,0,1-0.0764079444838941,0,0,0),
#         c(0,0.0546001011551592,0,0,0,1-0.0546001011551592,0,0),
#         c(0,0.0471954007706534,0,0,0,0,1-0.0471954007706534,0),
#         c(0,0.0477803263443933,0,0,0,0,0,1-0.0477803263443933),
#         c(0,0,0,0,0,0,0,1)
# )
tm_test = create_transition_matrix(user_engagement_by_msl_c, 'TEST', 8)
states_test = future_states(tm_test, state_names, initial_state, "Horoscope test", 20)
lift = rowSums(states_test[,1:7])/rowSums(states_control[,1:7])
df = data.frame("time"=1:20,"lift"=lift)
gg_lift =
ggplot(df, aes(x=time,y=lift)) +
geom_line() +
labs(x="Time in Months", y = "Email rechable member lift", title="Lift from horoscopes by month")
ggsave(gg_lift)
library(tidyverse)
library(RPostgreSQL)
library(markovchain)
connection = dbConnect(PostgreSQL(),
host="woden-redshift.p11a.com",
user="clay",
password="3P@1yKS0mIGvso1m6ZSh3VN%ZyJhM4h%",
dbname="woden",
port="5439")
user_engagement_by_msl_c = dbGetQuery(connection, paste("select * from user_engagement_by_msl_c"))
create_transition_matrix = function(df, cohort, num_states) {
df$user_ctr = with(df, user_clicks/users_sent)
df = df %>%
filter(test_control_flag == cohort) %>%
mutate(msl_c = msl_c + 1)
tm = matrix(rep(rep(0,num_states*num_states)),nrow=num_states,byrow=TRUE)
tm[1,2] = with(df %>% filter(arrival_type == 'r'), user_ctr)
tm[1,8] = with(df %>% filter(arrival_type == 'r'), 1 - user_ctr)
df = df %>% filter(arrival_type == 'e')
for (i in 2:(num_states-1)) {
user_ctr = with(df %>% filter(msl_c + 1 == i), user_ctr)
tm[i,i] = user_ctr
tm[i,i+1] = 1 - user_ctr
}
tm[8,8] = 1
tm
}
future_states = function(transition_matrix,state_names,initial_state, mc_name,time_periods=3) {
mc = new("markovchain", transitionMatrix=transition_matrix,states=state_names, name=mc_name)
num_states = length(initial_state)
states = matrix(rep(rep(0,num_states),time_periods),nrow=time_periods,byrow=TRUE)
for (i in 1:time_periods) {
if (i == 1)
next_state = initial_state*mc
else
next_state = states[i-1,]*mc
states[i,] = next_state
states[i,1] = 1200e3
}
return (states)
}
state_names = c("reg",0:6)
initial_state = c(932235,4366492,1404832,974552,830495,755575,587513,0)
# transition matrix for horoscope control
# tm <- c(c(0,0.50767681084216,0,0,0,0,0,1-0.50767681084216),
#         c(0,0.807562904585403,1-0.807562904585403,0,0,0,0,0),
#         c(0,0.095015298975791,0,1-0.095015298975791,0,0,0,0),
#         c(0,0.0724145205092642,0,0,1-0.0724145205092642,0,0,0),
#         c(0,0.0425663805949148,0,0,0,1-0.0425663805949148,0,0),
#         c(0,0.0361778900550916,0,0,0,0,1-0.0361778900550916,0),
#         c(0,0.0403998334027489,0,0,0,0,0,1-0.0403998334027489),
#         c(0,0,0,0,0,0,0,1)
# )
tm_control = create_transition_matrix(user_engagement_by_msl_c, 'CONTROL', 8)
states_control = future_states(tm_control, state_names, initial_state, "Horoscope control", 20)
# transition matrix for newsletter test
# tm <- c(c(0,0.507573048652163,0,0,0,0,0,1-0.507573048652163),
#         c(0,0.822892747445351,1-0.822892747445351,0,0,0,0,0),
#         c(0,0.116821861476424,0,1-0.116821861476424,0,0,0,0),
#         c(0,0.0764079444838941,0,0,1-0.0764079444838941,0,0,0),
#         c(0,0.0546001011551592,0,0,0,1-0.0546001011551592,0,0),
#         c(0,0.0471954007706534,0,0,0,0,1-0.0471954007706534,0),
#         c(0,0.0477803263443933,0,0,0,0,0,1-0.0477803263443933),
#         c(0,0,0,0,0,0,0,1)
# )
tm_test = create_transition_matrix(user_engagement_by_msl_c, 'TEST', 8)
states_test = future_states(tm_test, state_names, initial_state, "Horoscope test", 20)
lift = rowSums(states_test[,1:7])/rowSums(states_control[,1:7])
df = data.frame("time"=1:20,"lift"=lift)
gg_lift =
ggplot(df, aes(x=time,y=lift)) +
geom_line() +
labs(x="Time in Months", y = "Email rechable member lift", title="Lift from horoscopes by month")
ggsave("horoscope_list.png" gg_lift)
library(tidyverse)
library(RPostgreSQL)
library(markovchain)
connection = dbConnect(PostgreSQL(),
host="woden-redshift.p11a.com",
user="clay",
password="3P@1yKS0mIGvso1m6ZSh3VN%ZyJhM4h%",
dbname="woden",
port="5439")
user_engagement_by_msl_c = dbGetQuery(connection, paste("select * from user_engagement_by_msl_c"))
create_transition_matrix = function(df, cohort, num_states) {
df$user_ctr = with(df, user_clicks/users_sent)
df = df %>%
filter(test_control_flag == cohort) %>%
mutate(msl_c = msl_c + 1)
tm = matrix(rep(rep(0,num_states*num_states)),nrow=num_states,byrow=TRUE)
tm[1,2] = with(df %>% filter(arrival_type == 'r'), user_ctr)
tm[1,8] = with(df %>% filter(arrival_type == 'r'), 1 - user_ctr)
df = df %>% filter(arrival_type == 'e')
for (i in 2:(num_states-1)) {
user_ctr = with(df %>% filter(msl_c + 1 == i), user_ctr)
tm[i,i] = user_ctr
tm[i,i+1] = 1 - user_ctr
}
tm[8,8] = 1
tm
}
future_states = function(transition_matrix,state_names,initial_state, mc_name,time_periods=3) {
mc = new("markovchain", transitionMatrix=transition_matrix,states=state_names, name=mc_name)
num_states = length(initial_state)
states = matrix(rep(rep(0,num_states),time_periods),nrow=time_periods,byrow=TRUE)
for (i in 1:time_periods) {
if (i == 1)
next_state = initial_state*mc
else
next_state = states[i-1,]*mc
states[i,] = next_state
states[i,1] = 1200e3
}
return (states)
}
state_names = c("reg",0:6)
initial_state = c(932235,4366492,1404832,974552,830495,755575,587513,0)
# transition matrix for horoscope control
# tm <- c(c(0,0.50767681084216,0,0,0,0,0,1-0.50767681084216),
#         c(0,0.807562904585403,1-0.807562904585403,0,0,0,0,0),
#         c(0,0.095015298975791,0,1-0.095015298975791,0,0,0,0),
#         c(0,0.0724145205092642,0,0,1-0.0724145205092642,0,0,0),
#         c(0,0.0425663805949148,0,0,0,1-0.0425663805949148,0,0),
#         c(0,0.0361778900550916,0,0,0,0,1-0.0361778900550916,0),
#         c(0,0.0403998334027489,0,0,0,0,0,1-0.0403998334027489),
#         c(0,0,0,0,0,0,0,1)
# )
tm_control = create_transition_matrix(user_engagement_by_msl_c, 'CONTROL', 8)
states_control = future_states(tm_control, state_names, initial_state, "Horoscope control", 20)
# transition matrix for newsletter test
# tm <- c(c(0,0.507573048652163,0,0,0,0,0,1-0.507573048652163),
#         c(0,0.822892747445351,1-0.822892747445351,0,0,0,0,0),
#         c(0,0.116821861476424,0,1-0.116821861476424,0,0,0,0),
#         c(0,0.0764079444838941,0,0,1-0.0764079444838941,0,0,0),
#         c(0,0.0546001011551592,0,0,0,1-0.0546001011551592,0,0),
#         c(0,0.0471954007706534,0,0,0,0,1-0.0471954007706534,0),
#         c(0,0.0477803263443933,0,0,0,0,0,1-0.0477803263443933),
#         c(0,0,0,0,0,0,0,1)
# )
tm_test = create_transition_matrix(user_engagement_by_msl_c, 'TEST', 8)
states_test = future_states(tm_test, state_names, initial_state, "Horoscope test", 20)
lift = rowSums(states_test[,1:7])/rowSums(states_control[,1:7])
df = data.frame("time"=1:20,"lift"=lift)
gg_lift =
ggplot(df, aes(x=time,y=lift)) +
geom_line() +
labs(x="Time in Months", y = "Email rechable member lift", title="Lift from horoscopes by month")
ggsave("horoscope_list.png", gg_lift)
getwd()
user_engagement_by_msl_c = dbGetQuery(connection, paste("select * from user_engagement_by_msl_c"))
user_engagement_by_msl_c
library(tidyverse)
library(RPostgreSQL)
library(markovchain)
connection = dbConnect(PostgreSQL(),
host="woden-redshift.p11a.com",
user="clay",
password="3P@1yKS0mIGvso1m6ZSh3VN%ZyJhM4h%",
dbname="woden",
port="5439")
user_engagement_by_msl_c = dbGetQuery(connection, paste("select * from user_engagement_by_msl_c"))
create_transition_matrix = function(df, cohort, num_states) {
df$user_ctr = with(df, user_clicks/users_sent)
df = df %>%
filter(test_control_flag == cohort) %>%
mutate(msl_c = msl_c + 1)
tm = matrix(rep(rep(0,num_states*num_states)),nrow=num_states,byrow=TRUE)
tm[1,2] = with(df %>% filter(arrival_type == 'r'), user_ctr)
tm[1,8] = with(df %>% filter(arrival_type == 'r'), 1 - user_ctr)
df = df %>% filter(arrival_type == 'e')
for (i in 2:(num_states-1)) {
user_ctr = with(df %>% filter(msl_c + 1 == i), user_ctr)
tm[i,i] = user_ctr
tm[i,i+1] = 1 - user_ctr
}
tm[8,8] = 1
tm
}
future_states = function(transition_matrix,state_names,initial_state, mc_name,time_periods=3) {
mc = new("markovchain", transitionMatrix=transition_matrix,states=state_names, name=mc_name)
num_states = length(initial_state)
states = matrix(rep(rep(0,num_states),time_periods),nrow=time_periods,byrow=TRUE)
for (i in 1:time_periods) {
if (i == 1)
next_state = initial_state*mc
else
next_state = states[i-1,]*mc
states[i,] = next_state
states[i,1] = 1200e3
}
return (states)
}
state_names = c("reg",0:6)
initial_state = c(932235,4366492,1404832,974552,830495,755575,587513,0)
# transition matrix for horoscope control
# tm <- c(c(0,0.50767681084216,0,0,0,0,0,1-0.50767681084216),
#         c(0,0.807562904585403,1-0.807562904585403,0,0,0,0,0),
#         c(0,0.095015298975791,0,1-0.095015298975791,0,0,0,0),
#         c(0,0.0724145205092642,0,0,1-0.0724145205092642,0,0,0),
#         c(0,0.0425663805949148,0,0,0,1-0.0425663805949148,0,0),
#         c(0,0.0361778900550916,0,0,0,0,1-0.0361778900550916,0),
#         c(0,0.0403998334027489,0,0,0,0,0,1-0.0403998334027489),
#         c(0,0,0,0,0,0,0,1)
# )
tm_control = create_transition_matrix(user_engagement_by_msl_c, 'CONTROL', 8)
states_control = future_states(tm_control, state_names, initial_state, "Horoscope control", 20)
# transition matrix for newsletter test
# tm <- c(c(0,0.507573048652163,0,0,0,0,0,1-0.507573048652163),
#         c(0,0.822892747445351,1-0.822892747445351,0,0,0,0,0),
#         c(0,0.116821861476424,0,1-0.116821861476424,0,0,0,0),
#         c(0,0.0764079444838941,0,0,1-0.0764079444838941,0,0,0),
#         c(0,0.0546001011551592,0,0,0,1-0.0546001011551592,0,0),
#         c(0,0.0471954007706534,0,0,0,0,1-0.0471954007706534,0),
#         c(0,0.0477803263443933,0,0,0,0,0,1-0.0477803263443933),
#         c(0,0,0,0,0,0,0,1)
# )
tm_test = create_transition_matrix(user_engagement_by_msl_c, 'TEST', 8)
states_test = future_states(tm_test, state_names, initial_state, "Horoscope test", 20)
lift = rowSums(states_test[,1:7])/rowSums(states_control[,1:7])
df = data.frame("time"=1:20,"lift"=lift)
gg_lift =
ggplot(df, aes(x=time,y=lift)) +
geom_line() +
labs(x="Time in Months", y = "Email rechable member lift", title="Lift from newsletter by month")
ggsave("newsletter_list.png", gg_lift)
user_engagement_by_msl_c = dbGetQuery(connection, paste("select * from user_engagement_by_msl_c"))
create_transition_matrix = function(df, cohort, num_states) {
df$user_ctr = with(df, user_clicks/users_sent)
df = df %>%
filter(test_control_flag == cohort) %>%
mutate(msl_c = msl_c + 1)
tm = matrix(rep(rep(0,num_states*num_states)),nrow=num_states,byrow=TRUE)
tm[1,2] = with(df %>% filter(arrival_type == 'r'), user_ctr)
tm[1,8] = with(df %>% filter(arrival_type == 'r'), 1 - user_ctr)
df = df %>% filter(arrival_type == 'e')
for (i in 2:(num_states-1)) {
user_ctr = with(df %>% filter(msl_c + 1 == i), user_ctr)
tm[i,i] = user_ctr
tm[i,i+1] = 1 - user_ctr
}
tm[8,8] = 1
tm
}
future_states = function(transition_matrix,state_names,initial_state, mc_name,time_periods=3) {
mc = new("markovchain", transitionMatrix=transition_matrix,states=state_names, name=mc_name)
num_states = length(initial_state)
states = matrix(rep(rep(0,num_states),time_periods),nrow=time_periods,byrow=TRUE)
for (i in 1:time_periods) {
if (i == 1)
next_state = initial_state*mc
else
next_state = states[i-1,]*mc
states[i,] = next_state
states[i,1] = 1200e3
}
return (states)
}
state_names = c("reg",0:6)
initial_state = c(932235,4366492,1404832,974552,830495,755575,587513,0)
# transition matrix for horoscope control
# tm <- c(c(0,0.50767681084216,0,0,0,0,0,1-0.50767681084216),
#         c(0,0.807562904585403,1-0.807562904585403,0,0,0,0,0),
#         c(0,0.095015298975791,0,1-0.095015298975791,0,0,0,0),
#         c(0,0.0724145205092642,0,0,1-0.0724145205092642,0,0,0),
#         c(0,0.0425663805949148,0,0,0,1-0.0425663805949148,0,0),
#         c(0,0.0361778900550916,0,0,0,0,1-0.0361778900550916,0),
#         c(0,0.0403998334027489,0,0,0,0,0,1-0.0403998334027489),
#         c(0,0,0,0,0,0,0,1)
# )
tm_control = create_transition_matrix(user_engagement_by_msl_c, 'CONTROL', 8)
states_control = future_states(tm_control, state_names, initial_state, "Horoscope control", 20)
# transition matrix for newsletter test
# tm <- c(c(0,0.507573048652163,0,0,0,0,0,1-0.507573048652163),
#         c(0,0.822892747445351,1-0.822892747445351,0,0,0,0,0),
#         c(0,0.116821861476424,0,1-0.116821861476424,0,0,0,0),
#         c(0,0.0764079444838941,0,0,1-0.0764079444838941,0,0,0),
#         c(0,0.0546001011551592,0,0,0,1-0.0546001011551592,0,0),
#         c(0,0.0471954007706534,0,0,0,0,1-0.0471954007706534,0),
#         c(0,0.0477803263443933,0,0,0,0,0,1-0.0477803263443933),
#         c(0,0,0,0,0,0,0,1)
# )
tm_test = create_transition_matrix(user_engagement_by_msl_c, 'TEST', 8)
states_test = future_states(tm_test, state_names, initial_state, "Horoscope test", 20)
lift = rowSums(states_test[,1:7])/rowSums(states_control[,1:7])
df = data.frame("time"=1:20,"lift"=lift)
gg_lift =
ggplot(df, aes(x=time,y=lift)) +
geom_line() +
labs(x="Time in Months", y = "Email rechable member lift", title="Lift from weather by month")
ggsave("weather_list.png", gg_lift)
View(user_engagement_by_msl_c)
user_engagement_by_msl_c
user_engagement_by_msl_c = dbGetQuery(connection, paste("select * from user_engagement_by_msl_c"))
create_transition_matrix = function(df, cohort, num_states) {
df$user_ctr = with(df, user_clicks/users_sent)
df = df %>%
filter(test_control_flag == cohort) %>%
mutate(msl_c = msl_c + 1)
tm = matrix(rep(rep(0,num_states*num_states)),nrow=num_states,byrow=TRUE)
tm[1,2] = with(df %>% filter(arrival_type == 'r'), user_ctr)
tm[1,8] = with(df %>% filter(arrival_type == 'r'), 1 - user_ctr)
df = df %>% filter(arrival_type == 'e')
for (i in 2:(num_states-1)) {
user_ctr = with(df %>% filter(msl_c + 1 == i), user_ctr)
tm[i,i] = user_ctr
tm[i,i+1] = 1 - user_ctr
}
tm[8,8] = 1
tm
}
future_states = function(transition_matrix,state_names,initial_state, mc_name,time_periods=3) {
mc = new("markovchain", transitionMatrix=transition_matrix,states=state_names, name=mc_name)
num_states = length(initial_state)
states = matrix(rep(rep(0,num_states),time_periods),nrow=time_periods,byrow=TRUE)
for (i in 1:time_periods) {
if (i == 1)
next_state = initial_state*mc
else
next_state = states[i-1,]*mc
states[i,] = next_state
states[i,1] = 1200e3
}
return (states)
}
state_names = c("reg",0:6)
initial_state = c(932235,4366492,1404832,974552,830495,755575,587513,0)
# transition matrix for horoscope control
# tm <- c(c(0,0.50767681084216,0,0,0,0,0,1-0.50767681084216),
#         c(0,0.807562904585403,1-0.807562904585403,0,0,0,0,0),
#         c(0,0.095015298975791,0,1-0.095015298975791,0,0,0,0),
#         c(0,0.0724145205092642,0,0,1-0.0724145205092642,0,0,0),
#         c(0,0.0425663805949148,0,0,0,1-0.0425663805949148,0,0),
#         c(0,0.0361778900550916,0,0,0,0,1-0.0361778900550916,0),
#         c(0,0.0403998334027489,0,0,0,0,0,1-0.0403998334027489),
#         c(0,0,0,0,0,0,0,1)
# )
tm_control = create_transition_matrix(user_engagement_by_msl_c, 'CONTROL', 8)
states_control = future_states(tm_control, state_names, initial_state, "Horoscope control", 20)
# transition matrix for newsletter test
# tm <- c(c(0,0.507573048652163,0,0,0,0,0,1-0.507573048652163),
#         c(0,0.822892747445351,1-0.822892747445351,0,0,0,0,0),
#         c(0,0.116821861476424,0,1-0.116821861476424,0,0,0,0),
#         c(0,0.0764079444838941,0,0,1-0.0764079444838941,0,0,0),
#         c(0,0.0546001011551592,0,0,0,1-0.0546001011551592,0,0),
#         c(0,0.0471954007706534,0,0,0,0,1-0.0471954007706534,0),
#         c(0,0.0477803263443933,0,0,0,0,0,1-0.0477803263443933),
#         c(0,0,0,0,0,0,0,1)
# )
tm_test = create_transition_matrix(user_engagement_by_msl_c, 'TEST', 8)
states_test = future_states(tm_test, state_names, initial_state, "Horoscope test", 20)
lift = rowSums(states_test[,1:7])/rowSums(states_control[,1:7])
df = data.frame("time"=1:20,"lift"=lift)
gg_lift =
ggplot(df, aes(x=time,y=lift)) +
geom_line() +
labs(x="Time in Months", y = "Email rechable member lift", title="Lift from weather by month")
ggsave("weather_list.png", gg_lift)
gg_lift
library(tidyverse)
# read in data
X = read.table("q4/X.dat")
create_centroids = function(k=3)
data.frame(iter=1,
label=factor(sample(1:k)),
x=runif(k,min=min(X$V1),max=max(X$V1)),
y=runif(k,min=min(X$V2),max=max(X$V2)))
distance = function(x1,y1,x2,y2)
((x1-x2)^2 + (y1-y2)^2)^0.5
get_nearest_centroid = function(centroid_df, X) {
cdf = centroid_df
cdf$bool = TRUE
xdf = X
xdf$bool = TRUE
df = cdf %>%
#cross join cdf and xdf
inner_join(xdf, by = 'bool') %>%
# calculate distance to from every point to every centroid
mutate(distance = distance(x,y,V1,V2)) %>%
# get nearest centroid to each point
group_by(V1,V2) %>%
mutate(rank = rank(distance)) %>%
filter(rank == 1) %>%
select(iter, label, x,y,V1,V2,distance)
df
}
avg_distance = function(df) mean(df$distance)
get_new_centroids = function(df) {
df = df %>%
group_by(label) %>%
summarise(iter = min(iter) + 1,
x = mean(V1),
y = mean(V2))
df
}
centroids = create_centroids()
centroid_assignment = get_nearest_centroid(centroids, X)
avg_dist = avg_distance(centroid_assignment)
new_centroids = get_new_centroids(centroid_assignment)
centroid_assignment = get_nearest_centroid(new_centroids, X)
kmeans = function(X,k=3) {
tolerance = 0.05
delta = Inf
centroids = create_centroids(k=k)
centroid_assignment = get_nearest_centroid(centroids, X)
df_iters = centroid_assignment
dist0 = avg_distance(centroid_assignment)
while (delta > tolerance ) {
centroids = get_new_centroids(centroid_assignment)
centroid_assignment = get_nearest_centroid(centroids, X)
df_iters = df_iters %>% bind_rows(centroid_assignment)
dist1 = avg_distance(centroid_assignment)
delta = abs(dist1 - dist0)/dist0
dist0 = dist1
}
df_iters
}
kmeans_iters = kmeans(X, k=3)
gg = ggplot(kmeans_iters, aes(x = V1, y = V2, color = label)) +
geom_point() +
facet_wrap(~ iter) +
scale_color_discrete(guide="none")
ggsave("clusters_with_k3.png", gg)
getwd()
kmeans_iters = kmeans(X, k=2)
gg = ggplot(kmeans_iters, aes(x = V1, y = V2, color = label)) +
geom_point() +
facet_wrap(~ iter) +
scale_color_discrete(guide="none")
ggsave("clusters_with_k2.png", gg)
kmeans_iters = kmeans(X, k=4)
gg = ggplot(kmeans_iters, aes(x = V1, y = V2, color = label)) +
geom_point() +
facet_wrap(~ iter) +
scale_color_discrete(guide="none")
ggsave("clusters_with_k4.png", gg)
